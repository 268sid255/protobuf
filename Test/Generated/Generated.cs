// Classes and structures being serialized

// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
// To make custom modifications, edit the .csproto file and set external=true
// then write the code and the changes in a separate file.
using System;
using System.Collections.Generic;

namespace Personal
{
    public partial class Person
    {
        public enum PhoneType
        {
            MOBILE = 0,
            HOME = 1,
            WORK = 2,
        }

        public const int NameFieldID = 1;
        public string Name { get; set; }

        public const int IdFieldID = 2;
        public int Id { get; set; }

        public const int EmailFieldID = 3;
        public string Email { get; set; }

        public const int PhoneFieldID = 4;
        public List<Personal.Person.PhoneNumber> Phone { get; set; }

        public partial class PhoneNumber
        {
            public const int NumberFieldID = 1;
            public string Number { get; set; }

            public const int TypeFieldID = 2;
            public Personal.Person.PhoneType Type { get; set; }

        }

    }

    public partial class AddressBook
    {
        public const int ListFieldID = 1;
        public List<Personal.Person> List { get; set; }

    }

}
namespace Local
{
    /// <summary>This is a demonstration of features only present in ProtoBuf Code Generator</summary>
    internal partial class LocalFeatures
    {
        public const int UptimeFieldID = 1;
        /// <summary>Make class field of type TimeSpan, serialized to Ticks</summary>
        public TimeSpan Uptime { get; set; }

        public const int DueDateFieldID = 2;
        /// <summary>Make class field of type DateTime, serialized to Ticks</summary>
        public DateTime DueDate { get; set; }

        public const int AmountFieldID = 3;
        //public double Amount { get; set; } // Implemented by user elsewhere
        public const int DenialFieldID = 4;
        /// <summary>Custom field access types. Default: public</summary>
        private string Denial { get; set; }

        public const int SecretFieldID = 5;
        protected string Secret { get; set; }

        public const int InternalFieldID = 6;
        internal string Internal { get; set; }

        public const int PRFieldID = 7;
        public string PR { get; set; }

        public const int TestingReadOnlyFieldID = 8;
        /// <summary>Generate a c# readonly field</summary>
        public readonly Mine.MyMessageV1 TestingReadOnly = new Mine.MyMessageV1();

        public const int MyInterfaceFieldID = 9;
        /// <summary>When deserializing this one must be set to a class before</summary>
        public LocalFeatureTest.InterfaceTest MyInterface { get; set; }

        public const int MyStructFieldID = 10;
        public LocalFeatureTest.StructTest MyStruct;

        public const int MyExtStructFieldID = 11;
        public TestB.ExternalStruct MyExtStruct;

        public const int MyExtClassFieldID = 12;
        public TestB.ExternalClass MyExtClass { get; set; }

        public const int MyEnumFieldID = 13;
        public LocalFeatureTest.TopEnum MyEnum { get; set; }

        // protected virtual void BeforeSerialize() {}
        // protected virtual void AfterDeserialize() {}

    }

}
namespace LocalFeatureTest
{
    /// <summary>Testing local struct serialization</summary>
    public partial interface InterfaceTest
    {
    }

    /// <summary>Testing local struct serialization</summary>
    public partial struct StructTest
    {
    }

}
namespace TestB
{
    // Written elsewhere
    // public struct ExternalStruct {}

    // Written elsewhere
    // public class ExternalClass {}

}
namespace Mine
{
    /// <summary>
    /// <para>This class is documented here:</para>
    /// <para>With multiple lines</para>
    /// </summary>
    public partial class MyMessageV1
    {
        public const int FieldAFieldID = 1;
        /// <summary>This field is important to comment as we just did here</summary>
        public int FieldA { get; set; }

        /// <summary>Values for unknown fields.</summary>
        public List<ProtocolBuffers.KeyValue> PreservedFields;

    }

}
namespace Yours
{
    public partial class MyMessageV2
    {
        public enum MyEnum
        {
            /// <summary>First test</summary>
            ETest1 = 0,
            /// <summary>Second test</summary>
            ETest2 = 3,
            ETest3 = 2,
        }

        public const int FieldAFieldID = 1;
        public int FieldA { get; set; }

        public const int FieldBFieldID = 2;
        public double FieldB { get; set; }

        public const int FieldCFieldID = 3;
        public float FieldC { get; set; }

        public const int FieldDFieldID = 4;
        public int FieldD { get; set; }

        public const int FieldEFieldID = 5;
        public long FieldE { get; set; }

        public const int FieldFFieldID = 6;
        public uint FieldF { get; set; }

        public const int FieldGFieldID = 7;
        public ulong FieldG { get; set; }

        public const int FieldHFieldID = 8;
        public int FieldH { get; set; }

        public const int FieldIFieldID = 9;
        public long FieldI { get; set; }

        public const int FieldJFieldID = 10;
        public uint FieldJ { get; set; }

        public const int FieldKFieldID = 11;
        public ulong FieldK { get; set; }

        public const int FieldLFieldID = 12;
        public int FieldL { get; set; }

        public const int FieldMFieldID = 13;
        public long FieldM { get; set; }

        public const int FieldNFieldID = 14;
        public bool FieldN { get; set; }

        public const int FieldOFieldID = 15;
        public string FieldO { get; set; }

        public const int FieldPFieldID = 16;
        public byte[] FieldP { get; set; }

        public const int FieldQFieldID = 17;
        public Yours.MyMessageV2.MyEnum FieldQ { get; set; }

        public const int FieldRFieldID = 18;
        public Yours.MyMessageV2.MyEnum FieldR { get; set; }

        public const int DummyFieldID = 19;
        protected string Dummy { get; set; }

        public const int FieldTFieldID = 20;
        public List<uint> FieldT { get; set; }

        public const int FieldSFieldID = 21;
        public List<uint> FieldS { get; set; }

        public const int FieldUFieldID = 22;
        public Theirs.TheirMessage FieldU { get; set; }

        public const int FieldVFieldID = 23;
        public List<Theirs.TheirMessage> FieldV { get; set; }

    }

}
namespace Theirs
{
    public partial class TheirMessage
    {
        public const int FieldAFieldID = 1;
        public int FieldA { get; set; }

    }

}
namespace Proto.test
{
    /// <summary>Message without any low id(< 16) fields</summary>
    public partial class LongMessage
    {
        public const int FieldX1FieldID = 32;
        public int FieldX1 { get; set; }

        public const int FieldX2FieldID = 64;
        public int FieldX2 { get; set; }

        public const int FieldX3FieldID = 96;
        public int FieldX3 { get; set; }

        public const int FieldX4FieldID = 100;
        public int FieldX4 { get; set; }

    }

}
namespace LocalFeatureTest
{
    public enum TopEnum
    {
        First = 1,
        Last = 1000000,
    }


}
