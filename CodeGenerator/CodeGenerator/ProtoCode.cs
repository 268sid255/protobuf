using System;
using System.IO;
using System.Text;
using System.Reflection;
using ProtocolBuffers;
using System.Collections.Generic;

namespace ProtocolBuffers
{
	static class ProtoCode
	{
		/// <summary>
		/// Generate code for reading and writing protocol buffer messages
		/// </summary>
		public static void Save (Proto proto, MessageCode codeGen, string csPath)
		{
			string ext = Path.GetExtension (csPath);
			string prefix = csPath.Substring (0, csPath.Length - ext.Length);

			string csDir = Path.GetDirectoryName(csPath);
			if(Directory.Exists (csDir) == false)
				Directory.CreateDirectory(csDir);

			//Basic structures
			using (TextWriter codeWriter = new StreamWriter(csPath, false, Encoding.UTF8)) {
				codeWriter.WriteLine (@"//
//	You may customize this code as you like
//	Report bugs to: https://silentorbit.com/protobuf/
//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//
using System;
using System.Collections.Generic;
");
				
				foreach (Message m in proto.Messages) {
					codeWriter.WriteLine ("namespace " + m.Namespace);
					codeWriter.WriteLine ("{");
					codeWriter.WriteLine (Code.Indent (1, codeGen.GenerateClass (m)));
					codeWriter.WriteLine ("}");
				}
			}
			
			//.Serializer.cs
			//Code for Reading/Writing 
			using (TextWriter codeWriter = new StreamWriter(prefix + ".Serializer" + ext, false, Encoding.UTF8)) {
				codeWriter.WriteLine (@"//
//	This is the backend code for reading and writing
//	Report bugs to: https://silentorbit.com/protobuf/
//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;
");

				foreach (Message m in proto.Messages) {
					codeWriter.WriteLine ("namespace " + m.Namespace);
					codeWriter.WriteLine ("{");
					codeWriter.WriteLine (Code.Indent (1, SerializerCode.GenerateClassSerializer (m)));
					codeWriter.WriteLine ("}");
				}

				codeWriter.WriteLine (@"
namespace ProtocolBuffers
{
	public static partial class Serializer
	{");

				foreach (Message m in proto.Messages)
					codeWriter.WriteLine (Code.Indent (2, SerializerCode.GenerateGenericClassSerializer (m)));
					
				codeWriter.WriteLine (@"
	}
}");
			}
				
			string libPath = Path.Combine (Path.GetDirectoryName (csPath), "ProtocolParser.cs");
			using (TextWriter codeWriter = new StreamWriter(libPath, false, Encoding.UTF8)) {
				ReadCode (codeWriter, "ProtocolParser", true);
				ReadCode (codeWriter, "ProtocolParserFixed", false);
				ReadCode (codeWriter, "ProtocolParserKey", false);
				ReadCode (codeWriter, "ProtocolParserVarInt", false);
				ReadCode (codeWriter, "ProtocolParserCustom", false);
			}
		}
		
		/// <summary>
		/// Read c# code from sourcePath and write it on code without the initial using statements.
		/// </summary>
		private static void ReadCode (TextWriter code, string name, bool includeUsing)
		{
			code.WriteLine ("#region " + name);
			
			using (TextReader tr = new StreamReader(Assembly.GetExecutingAssembly ().GetManifestResourceStream (name), Encoding.UTF8)) {
				while (true) {
					string line = tr.ReadLine ();
					if (line == null)
						break;
					if (includeUsing == false && line.StartsWith ("using"))
						continue;
					
					code.WriteLine (line);
				}
			}
			code.WriteLine ("#endregion");
		}
		
	}
}

