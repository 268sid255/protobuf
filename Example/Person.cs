//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;

namespace Example
{

	public interface IPerson
	{
		string Name { get; set; }
		int Id { get; set; }
		string Email { get; set; }
		IList<IPhoneNumber> Phone { get; set; }
	}

	public class Person : IPerson
	{
		public string Name { get; set; }
		public int Id { get; set; }
		public string Email { get; set; }
		public IList<IPhoneNumber> Phone { get; set; }

		public Person()
		{
			this.Phone = new List<IPhoneNumber>();
		}
		public static IPerson Read(Stream stream)
		{
			return Read(stream, new Person());
		}
		public static IPerson Read(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Read(ms, new Person());
		}
		public static IPerson Read(byte[] buffer, IPerson instance)
		{
			if(instance == null)
				instance = new Person();
			using(MemoryStream ms = new MemoryStream(buffer))
				return Read(ms, instance);
		}
		public static IPerson Read (Stream stream, IPerson instance)
		{
			while (true)
			{
				Key key = null;
				try {
					key = ProtocolParser.ReadKey (stream);
				} catch (InvalidDataException) {
					break;
				}
				
				switch (key.Field) {
				case 1:
					instance.Name = ProtocolParser.ReadString(stream);
					break;
				case 2:
					instance.Id = (int)ProtocolParser.ReadUInt32(stream);
					break;
				case 3:
					instance.Email = ProtocolParser.ReadString(stream);
					break;
				case 4:
					instance.Phone.Add(PhoneNumber.Read(ProtocolParser.ReadBytes(stream)));
					break;
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			return instance;
		}
		public static void Write(Stream stream, IPerson instance)
		{
			if(instance.Name == null)
				throw new ArgumentNullException("Name", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteString(stream, instance.Name);
			ProtocolParser.WriteKey(stream, new Key(2, Wire.Varint));
			ProtocolParser.WriteUInt32(stream, (uint)instance.Id);
			if(instance.Email != null)
			{
				ProtocolParser.WriteKey(stream, new Key(3, Wire.LengthDelimited));
				ProtocolParser.WriteString(stream, instance.Email);
			}
			foreach (PhoneNumber i4 in instance.Phone)
			{
				ProtocolParser.WriteKey(stream, new Key(4, Wire.LengthDelimited));
				using(MemoryStream ms4 = new MemoryStream())
				{
					PhoneNumber.Write(ms4, i4);
					ProtocolParser.WriteBytes(stream, ms4.ToArray());
				}
			}
		}

	}

	public interface IPhoneNumber
	{
		string Number { get; set; }
		PhoneNumber.PhoneType Type { get; set; }
	}

	public class PhoneNumber : IPhoneNumber
	{
		public enum PhoneType
		{
			MOBILE = 0,
			HOME = 1,
			WORK = 2,
		}

		public string Number { get; set; }
		public PhoneNumber.PhoneType Type { get; set; }

		public PhoneNumber()
		{
			this.Type = PhoneNumber.PhoneType.HOME;
		}
		public static IPhoneNumber Read(Stream stream)
		{
			return Read(stream, new PhoneNumber());
		}
		public static IPhoneNumber Read(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Read(ms, new PhoneNumber());
		}
		public static IPhoneNumber Read(byte[] buffer, IPhoneNumber instance)
		{
			if(instance == null)
				instance = new PhoneNumber();
			using(MemoryStream ms = new MemoryStream(buffer))
				return Read(ms, instance);
		}
		public static IPhoneNumber Read (Stream stream, IPhoneNumber instance)
		{
			while (true)
			{
				Key key = null;
				try {
					key = ProtocolParser.ReadKey (stream);
				} catch (InvalidDataException) {
					break;
				}
				
				switch (key.Field) {
				case 1:
					instance.Number = ProtocolParser.ReadString(stream);
					break;
				case 2:
					instance.Type = (PhoneNumber.PhoneType)ProtocolParser.ReadUInt32(stream);
					break;
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			return instance;
		}
		public static void Write(Stream stream, IPhoneNumber instance)
		{
			if(instance.Number == null)
				throw new ArgumentNullException("Number", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteString(stream, instance.Number);
			ProtocolParser.WriteKey(stream, new Key(2, Wire.Varint));
			ProtocolParser.WriteUInt32(stream, (uint)instance.Type);
		}

	}

}
#region ProtocolParser.cs

// 
//	Read/Write string and byte arrays 
// 
namespace ProtocolBuffers
{
	public static partial class ProtocolParser
	{
		
		public static string ReadString (Stream stream)
		{
			return Encoding.UTF8.GetString (ReadBytes (stream));
		}
		
		public static byte[] ReadBytes (Stream stream)
		{
			//VarInt length
			uint length = ReadUInt32 (stream);
			
			//Bytes
			byte[] buffer = new byte[length];
			stream.Read (buffer, 0, buffer.Length);
			return buffer;
		}
		
		public static void WriteString (Stream stream, string val)
		{
			WriteBytes (stream, Encoding.UTF8.GetBytes (val));
		}
		
		public static void WriteBytes (Stream stream, byte[] val)
		{
			WriteUInt32 (stream, (uint)val.Length);
			stream.Write (val, 0, val.Length);
		}
		
	}
}

#endregion
#region ProtocolParserFixed.cs
//
//	This file contain references on how to write and read
//	fixed integers and float/double.
//	

namespace ProtocolBuffers
{
	public static partial class ProtocolParser
	{
		#region Fixed Int
		
		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static ulong ReadFixed64 (BinaryReader reader)
		{
			return reader.ReadUInt64 ();
		}

		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static long ReadSFixed64 (BinaryReader reader)
		{
			return reader.ReadInt64 ();
		}
		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static uint ReadFixed32 (BinaryReader reader)
		{
			return reader.ReadUInt32 ();
		}

		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static int ReadSFixed32 (BinaryReader reader)
		{
			return reader.ReadInt32 ();
		}
		
		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static void WriteFixed64 (BinaryWriter writer, ulong val)
		{
			writer.Write (val);
		}

		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static void WriteSFixed64 (BinaryWriter writer, long val)
		{
			writer.Write (val);
		}
		
		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static void WriteFixed32 (BinaryWriter writer, uint val)
		{
			writer.Write (val);
		}

		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static void WriteSFixed32 (BinaryWriter writer, int val)
		{
			writer.Write (val);
		}
		
		#endregion
		
		#region Fixed: float, double

		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static float ReadFloat (BinaryReader reader)
		{
			return reader.ReadSingle ();
		}
		
		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static double ReadDouble (BinaryReader reader)
		{
			return reader.ReadDouble ();
		}

		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static void WriteFloat (BinaryWriter writer, float val)
		{
			writer.Write (val);
		}
		
		/// <summary>
		/// Only for reference
		/// </summary>
		[Obsolete("Only for reference")]
		public static void WriteDouble (BinaryWriter writer, double val)
		{
			writer.Write (val);
		}


		#endregion
		
	}
}

#endregion
#region ProtocolParserKey.cs
//
//	Reader/Writer for field key
//

namespace ProtocolBuffers
{
	public enum Wire
	{
		Varint = 0,		//int32, int64, uint32, uint64, sint32, sint64, bool, enum
		Fixed64 = 1,	//fixed64, sfixed64, double
		LengthDelimited = 2,	//string, bytes, embedded messages, packed repeated fields
		//Start = 3, 		//	groups (deprecated)
		//End = 4,		//	groups (deprecated)
		Fixed32 = 5,	//32-bit	fixed32, sfixed32, float
	}

	public class Key
	{
		public uint Field { get; set; }

		public Wire WireType { get; set; }
		
		public Key (uint field, Wire wireType)
		{
			this.Field = field;
			this.WireType = wireType;				
		}
	}
	
	public static partial class ProtocolParser
	{
		
		public static Key ReadKey (Stream stream)
		{
			uint n = ReadUInt32 (stream);
			return new Key (n >> 3, (Wire)(n & 0x07));
		}
		
		public static void WriteKey (Stream stream, Key key)
		{
			uint n = (key.Field << 3) | ((uint)key.WireType);
			WriteUInt32 (stream, n);
		}
		
		public static void SkipKey(Stream stream, Key key)
		{
			switch (key.WireType) {
			case Wire.Fixed32:
				stream.Seek (4, SeekOrigin.Current);
				return;
			case Wire.Fixed64:
				stream.Seek (8, SeekOrigin.Current);
				return;
			case Wire.LengthDelimited:
				stream.Seek (ProtocolParser.ReadUInt32 (stream), SeekOrigin.Current);
				return;
			case Wire.Varint:
				ProtocolParser.ReadSkipVarInt (stream);
				return;
			default:
				throw new NotImplementedException ();
			}
		}
	}
}

#endregion
#region ProtocolParserVarInt.cs

namespace ProtocolBuffers
{
	public static partial class ProtocolParser
	{
		/// <summary>
		/// Reads past a varint for an unknown field.
		/// </summary>
		public static void ReadSkipVarInt (Stream stream)
		{
			while (true) {
				int b = stream.ReadByte ();
				if (b < 0)
					throw new InvalidDataException ("Stream ended too early");
				
				if ((b & 0x80) == 0)
					return; //end of varint
			}
		}
		
		#region VarInt: int32, uint32, sint32
		
		[Obsolete("Use (int)ReadUInt32 (stream);")]
		/// <summary>
		/// Since the int32 format is inefficient for negative numbers we have avoided to imlplement.
		/// The same functionality can be achieved using: (int)ReadUInt32 (stream);
		/// </summary>
		public static int ReadInt32 (Stream stream)
		{
			throw new NotImplementedException ("Use (int)ReadUInt32 (stream);");
		}
		
		[Obsolete("Use WriteUInt32 (stream, (uint)val);")]
		/// <summary>
		/// Since the int32 format is inefficient for negative numbers we have avoided to imlplement.
		/// The same functionality can be achieved using: WriteUInt32 (stream, (uint)val);
		/// </summary>
		public static void WriteInt32 (Stream stream, int val)
		{
			throw new NotImplementedException ("Use WriteUInt32 (stream, (uint)val);");
		}
		
		public static int ReadSInt32 (Stream stream)
		{
			uint uval = ReadUInt32 (stream);
			return (int)((uval >> 1) | (uval << 31));
			
		}
		
		public static void WriteSInt32 (Stream stream, int val)
		{
			uint uval = (uint)val;
			WriteUInt32 (stream, (uval << 1) | (uval >> 31));
		}

		public static uint ReadUInt32 (Stream stream)
		{
			int b;
			uint val = 0;
			
			for (int n = 0; n < 5; n++) {
				b = stream.ReadByte ();
				if (b < 0)
					throw new InvalidDataException ("Stream ended too early");
				
				//Check that it fits in 32 bits
				if ((n == 4) && (b & 0xF0) != 0)
					throw new InvalidDataException ("Got larger VarInt than 32bit unsigned");
				//End of check
				
				if ((b & 0x80) == 0)
					return val | (uint)(b << (7 * n));
				
				val |= (uint)(b & 0x7F) << (7 * n);
			}
			
			throw new InvalidDataException ("Got larger VarInt than 32bit unsigned");
		}
		
		public static void WriteUInt32 (Stream stream, uint val)
		{
			byte[] buffer = new byte[5];
			int count = 0;
			
			while (true) {
				buffer [count] = (byte)(val & 0x7F);
				val = val >> 7;
				if (val == 0)
					break;
				
				buffer [count] |= 0x80;
				
				count += 1;
			}
			
			stream.Write (buffer, 0, count + 1);
		}
		
		#endregion
		
		#region VarInt: int64, uint64, sint64
		
		[Obsolete("Use (long)ReadUInt64 (stream); instead")]
		/// <summary>
		/// Since the int64 format is inefficient for negative numbers we have avoided to implement it.
		/// The same functionality can be achieved using: (long)ReadUInt64 (stream);
		/// </summary>
		public static int ReadInt64 (Stream stream)
		{
			throw new NotImplementedException ("Use (int)ReadUInt64 (stream); instead");
		}
		
		[Obsolete("Use WriteUInt64 (stream, (ulong)val); instead")]
		/// <summary>
		/// Since the int64 format is inefficient for negative numbers we have avoided to implement.
		/// The same functionality can be achieved using: WriteUInt64 (stream, (ulong)val);
		/// </summary>
		public static void WriteInt64 (Stream stream, int val)
		{
			throw new NotImplementedException ("Use WriteUInt64 (stream, (ulong)val); instead");
		}

		public static long ReadSInt64 (Stream stream)
		{
			ulong uval = ReadUInt64 (stream);
			return (long)((uval >> 1) | (uval << 63));
			
		}
		
		public static void WriteSInt64 (Stream stream, long val)
		{
			ulong uval = (ulong)val;
			WriteUInt64 (stream, (uval << 1) | (uval >> 63));
		}

		public static ulong ReadUInt64 (Stream stream)
		{
			int b;
			ulong val = 0;
			
			for (int n = 0; n < 10; n++) {
				b = stream.ReadByte ();
				if (b < 0)
					throw new InvalidDataException ("Stream ended too early");
				
				//Check that it fits in 64 bits
				if ((n == 9) && (b & 0xFE) != 0)
					throw new InvalidDataException ("Got larger VarInt than 64 bit unsigned");
				//End of check
				
				if ((b & 0x80) == 0)
					return val | (ulong)(b << (7 * n));
				
				val |= (ulong)(b & 0x7F) << (7 * n);
			}
			
			throw new InvalidDataException ("Got larger VarInt than 64 bit unsigned");
		}
		
		public static void WriteUInt64 (Stream stream, ulong val)
		{
			byte[] buffer = new byte[10];
			int count = 0;
			
			while (true) {
				buffer [count] = (byte)(val & 0x7F);
				val = val >> 7;
				if (val == 0)
					break;
				
				buffer [count] |= 0x80;
				
				count += 1;
			}
			
			stream.Write (buffer, 0, count + 1);
		}
		
		#endregion
		
		#region Varint: bool
		
		public static bool ReadBool (Stream stream)
		{
			int b = stream.ReadByte ();
			if (b < 0)
				throw new InvalidDataException ("Stream ended too early");
			if (b == 1)
				return true;
			if (b == 0)
				return false;
			throw new InvalidDataException ("Invalid boolean value");
		}
		
		public static void WriteBool (Stream stream, bool val)
		{
			stream.WriteByte (val ? (byte)1 : (byte)0);
		}
		
		#endregion
	}
}
#endregion
